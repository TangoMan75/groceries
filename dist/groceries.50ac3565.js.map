{"mappings":"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","sources":["<anon>","src/js/main.js","src/js/dataStore.js"],"sourcesContent":["// Grocery List App - Main JavaScript\n/**\n * Enhanced DataStore class for managing persistent data storage\n * Supports both Chrome extension storage API and browser localStorage fallback\n * @class DataStore\n */ class $c369b942a8093473$export$47a0e4800a1fd7dc {\n    /**\n     * Create a DataStore instance\n     * @param {string} namespace - The storage namespace/key\n     * @param {string} [type='local'] - Storage type: 'local', 'sync', 'managed', 'session'\n     * @throws {Error} When namespace is invalid\n     */ constructor(namespace, type = 'local'){\n        this._validateNamespace(namespace);\n        this.namespace = namespace;\n        this.validTypes = [\n            'local',\n            'sync',\n            'managed',\n            'session'\n        ];\n        this.type = this.validTypes.includes(type) ? type : 'local';\n        this._initializeStorage();\n        this._eventListeners = new Map();\n    }\n    /**\n     * Validate namespace parameter\n     * @private\n     * @param {*} namespace - The namespace to validate\n     * @throws {Error} When namespace is invalid\n     */ _validateNamespace(namespace) {\n        if (typeof namespace !== 'string') throw new TypeError('Namespace must be a string');\n        if (!namespace.trim()) throw new Error('Namespace cannot be empty');\n        if (namespace.length > 255) throw new Error('Namespace cannot exceed 255 characters');\n        if (!/^[a-zA-Z0-9._-]+$/.test(namespace)) throw new Error('Namespace contains invalid characters. Only alphanumeric, dots, underscores, and hyphens are allowed');\n    }\n    /**\n     * Initialize storage with Chrome extension API or localStorage fallback\n     * @private\n     */ _initializeStorage() {\n        try {\n            // Check if Chrome extension API is available\n            if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage[this.type]) {\n                this.storage = chrome.storage[this.type];\n                this.storageType = 'chrome';\n            } else {\n                // Fallback to localStorage/sessionStorage\n                this.storage = this.type === 'session' ? sessionStorage : localStorage;\n                this.storageType = 'web';\n            }\n        } catch (error) {\n            this.storage = localStorage;\n            this.storageType = 'web';\n            console.warn('DataStore: Falling back to localStorage due to:', error.message);\n        }\n    }\n    /**\n     * Get data from storage\n     * @param {*} [defaultValue=undefined] - Default value if key doesn't exist\n     * @returns {Promise<*>} The stored value or default value\n     */ async get(defaultValue) {\n        try {\n            if (this.storageType === 'chrome') return new Promise((resolve, reject)=>{\n                this.storage.get([\n                    this.namespace\n                ], (result)=>{\n                    if (chrome.runtime.lastError) reject(new Error(`Chrome storage error: ${chrome.runtime.lastError.message}`));\n                    else {\n                        const value = result[this.namespace];\n                        resolve(value !== undefined ? value : defaultValue);\n                    }\n                });\n            });\n            else {\n                // Web storage fallback\n                const item = this.storage.getItem(this.namespace);\n                if (item === null) return defaultValue;\n                try {\n                    return JSON.parse(item);\n                } catch (parseError) {\n                    console.warn(`DataStore: Failed to parse stored data for ${this.namespace}:`, parseError);\n                    return defaultValue;\n                }\n            }\n        } catch (error) {\n            console.error(`DataStore: Error getting data for ${this.namespace}:`, error);\n            throw new Error(`Failed to get data: ${error.message}`);\n        }\n    }\n    /**\n     * Set data in storage\n     * @param {*} value - The value to store\n     * @returns {Promise<void>}\n     * @throws {Error} When storage operation fails\n     */ async set(value) {\n        try {\n            this._validateValue(value);\n            if (this.storageType === 'chrome') return new Promise((resolve, reject)=>{\n                this.storage.set({\n                    [this.namespace]: value\n                }, ()=>{\n                    if (chrome.runtime.lastError) reject(new Error(`Chrome storage error: ${chrome.runtime.lastError.message}`));\n                    else {\n                        this._dispatchChangeEvent('set', value);\n                        resolve();\n                    }\n                });\n            });\n            else try {\n                const serialized = JSON.stringify(value);\n                this.storage.setItem(this.namespace, serialized);\n                this._dispatchChangeEvent('set', value);\n            } catch (storageError) {\n                if (storageError.name === 'QuotaExceededError') throw new Error('Storage quota exceeded');\n                throw storageError;\n            }\n        } catch (error) {\n            console.error(`DataStore: Error setting data for ${this.namespace}:`, error);\n            throw new Error(`Failed to set data: ${error.message}`);\n        }\n    }\n    /**\n     * Validate that a value can be stored\n     * @private\n     * @param {*} value - The value to validate\n     * @throws {Error} When value cannot be stored\n     */ _validateValue(value) {\n        if (value === undefined) throw new Error('Cannot store undefined value');\n        try {\n            JSON.stringify(value);\n        } catch (error) {\n            if (error.message.includes('circular')) throw new Error('Cannot store value with circular references');\n            throw new Error(`Value is not serializable: ${error.message}`);\n        }\n    }\n    /**\n     * Add a value to an array stored in the namespace\n     * @param {*} value - The value to add\n     * @param {boolean} [allowDuplicates=true] - Whether to allow duplicate values\n     * @returns {Promise<number>} The new length of the array\n     * @throws {Error} When the stored data is not an array or value is invalid\n     */ async add(value, allowDuplicates = true) {\n        if (value === undefined || value === null) throw new Error(`Cannot add undefined or null value to \"${this.namespace}\"`);\n        try {\n            const data = await this.get([]);\n            if (!Array.isArray(data)) throw new Error(`\"${this.namespace}\" does not contain an array`);\n            if (!allowDuplicates && data.some((item)=>JSON.stringify(item) === JSON.stringify(value))) throw new Error('Duplicate value not allowed');\n            data.push(value);\n            await this.set(data);\n            return data.length;\n        } catch (error) {\n            console.error(`DataStore: Error adding value to ${this.namespace}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Clear all data in the entire namespace from storage\n     * @returns {Promise<void>}\n     * @throws {Error} When deletion fails\n     */ async clear() {\n        try {\n            if (this.storageType === 'chrome') return new Promise((resolve, reject)=>{\n                this.storage.remove([\n                    this.namespace\n                ], ()=>{\n                    if (chrome.runtime.lastError) reject(new Error(`Chrome storage error: ${chrome.runtime.lastError.message}`));\n                    else {\n                        this._dispatchChangeEvent('clear');\n                        resolve();\n                    }\n                });\n            });\n            else {\n                // Web storage fallback\n                this.storage.removeItem(this.namespace);\n                this._dispatchChangeEvent('clear');\n            }\n        } catch (error) {\n            console.error(`DataStore: Error deleting ${this.namespace}:`, error);\n            throw new Error(`Failed to delete data: ${error.message}`);\n        }\n    }\n    /**\n     * Append a value to an array at a specific path within the stored object\n     * @param {string} itemPath - Dot-notation path to the array (e.g., 'user.preferences.items')\n     * @param {*} value - The value to append\n     * @returns {Promise<number>} The new length of the array\n     * @throws {Error} When path is invalid, target is not an array, or value is invalid\n     */ async appendItem(itemPath, value) {\n        if (value === undefined || value === null) throw new Error(`Cannot add undefined or null value to \"${itemPath}\"`);\n        this._validatePath(itemPath);\n        try {\n            const data = await this.get();\n            if (!data) throw new Error(`No data found in namespace \"${this.namespace}\"`);\n            const { parent: parent, key: key } = this._navigateToPath(data, itemPath);\n            if (!Array.isArray(parent[key])) throw new Error(`Path \"${itemPath}\" does not point to an array`);\n            parent[key].push(value);\n            await this.set(data);\n            return parent[key].length;\n        } catch (error) {\n            console.error(`DataStore: Error appending to ${itemPath}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Edit/update a value at a specific path within the stored object\n     * @param {string} itemPath - Dot-notation path to the value (e.g., 'user.name')\n     * @param {*} value - The new value\n     * @param {boolean} [createPath=false] - Whether to create the path if it doesn't exist\n     * @returns {Promise<void>}\n     * @throws {Error} When path is invalid or not found\n     */ async editItem(itemPath, value, createPath = false) {\n        this._validatePath(itemPath);\n        try {\n            let data = await this.get();\n            if (!data) {\n                if (createPath) data = {};\n                else throw new Error(`No data found in namespace \"${this.namespace}\"`);\n            }\n            const { parent: parent, key: key } = this._navigateToPath(data, itemPath, createPath);\n            if (!createPath && !(key in parent)) throw new Error(`Path \"${itemPath}\" not found`);\n            const oldValue = parent[key];\n            parent[key] = value;\n            await this.set(data);\n            this._dispatchChangeEvent('edit', {\n                path: itemPath,\n                oldValue: oldValue,\n                newValue: value\n            });\n        } catch (error) {\n            console.error(`DataStore: Error editing ${itemPath}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Delete an item at a specific path within the stored object\n     * @param {string} itemPath - Dot-notation path to the value to delete\n     * @returns {Promise<boolean>} True if item was deleted, false if not found\n     * @throws {Error} When path is invalid\n     */ async deleteItem(itemPath) {\n        this._validatePath(itemPath);\n        try {\n            const data = await this.get();\n            if (!data) return false;\n            const { parent: parent, key: key } = this._navigateToPath(data, itemPath);\n            if (!(key in parent)) return false;\n            const deletedValue = parent[key];\n            if (Array.isArray(parent)) {\n                const index = Number(key);\n                if (isNaN(index) || index < 0 || index >= parent.length) throw new Error(`Invalid array index: ${key}`);\n                parent.splice(index, 1);\n            } else delete parent[key];\n            await this.set(data);\n            this._dispatchChangeEvent('deleteItem', {\n                path: itemPath,\n                deletedValue: deletedValue\n            });\n            return true;\n        } catch (error) {\n            console.error(`DataStore: Error deleting ${itemPath}:`, error);\n            throw error;\n        }\n    }\n    // === UTILITY METHODS ===\n    /**\n     * Update data using a function\n     * @param {Function} updater - Function that receives current data and returns new data\n     * @param {*} [defaultValue] - Default value if no data exists\n     * @returns {Promise<*>} The updated data\n     */ async update(updater, defaultValue) {\n        if (typeof updater !== 'function') throw new TypeError('Updater must be a function');\n        try {\n            const currentData = await this.get(defaultValue);\n            const newData = updater(currentData);\n            await this.set(newData);\n            return newData;\n        } catch (error) {\n            console.error(`DataStore: Error updating ${this.namespace}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Merge an object with existing data\n     * @param {Object} newData - Object to merge\n     * @param {boolean} [deep=false] - Whether to perform deep merge\n     * @returns {Promise<Object>} The merged data\n     */ async merge(newData, deep = false) {\n        if (typeof newData !== 'object' || newData === null || Array.isArray(newData)) throw new TypeError('Data to merge must be a plain object');\n        try {\n            const currentData = await this.get({});\n            if (typeof currentData !== 'object' || Array.isArray(currentData)) throw new Error('Cannot merge with non-object data');\n            const merged = deep ? this._deepMerge(currentData, newData) : {\n                ...currentData,\n                ...newData\n            };\n            await this.set(merged);\n            return merged;\n        } catch (error) {\n            console.error(`DataStore: Error merging data in ${this.namespace}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Validate a dot-notation path\n     * @private\n     * @param {string} path - The path to validate\n     */ _validatePath(path) {\n        if (typeof path !== 'string' || !path.trim()) throw new Error('Path must be a non-empty string');\n    }\n    /**\n     * Navigate to a path within an object, optionally creating missing parts\n     * @private\n     * @param {Object} data - The data object to navigate\n     * @param {string} path - Dot-notation path\n     * @param {boolean} [create=false] - Whether to create missing path parts\n     * @returns {Object} Object with parent and key properties\n     */ _navigateToPath(data, path, create = false) {\n        const pathParts = path.split('.');\n        const key = pathParts.pop();\n        let parent = data;\n        for (const part of pathParts){\n            if (parent == null) throw new Error(`Cannot navigate through null/undefined at path \"${path}\"`);\n            if (!(part in parent)) {\n                if (create) parent[part] = {};\n                else throw new Error(`Path \"${path}\" not found`);\n            }\n            parent = parent[part];\n        }\n        return {\n            parent: parent,\n            key: key\n        };\n    }\n    /**\n     * Deep merge two objects\n     * @private\n     * @param {Object} target - Target object\n     * @param {Object} source - Source object\n     * @returns {Object} Merged object\n     */ _deepMerge(target, source) {\n        const result = {\n            ...target\n        };\n        for(const key in source)if (source.hasOwnProperty(key)) {\n            if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key]) && typeof result[key] === 'object' && result[key] !== null && !Array.isArray(result[key])) result[key] = this._deepMerge(result[key], source[key]);\n            else result[key] = source[key];\n        }\n        return result;\n    }\n    /**\n     * Dispatch change events\n     * @private\n     * @param {string} type - Event type\n     * @param {*} [data] - Event data\n     */ _dispatchChangeEvent(type, data = null) {\n        try {\n            if (typeof window !== 'undefined') window.dispatchEvent(new CustomEvent('datastore-changed', {\n                detail: {\n                    namespace: this.namespace,\n                    type: type,\n                    data: data,\n                    timestamp: Date.now()\n                }\n            }));\n            const listeners = this._eventListeners.get(type) || [];\n            listeners.forEach((callback)=>{\n                try {\n                    callback({\n                        namespace: this.namespace,\n                        type: type,\n                        data: data\n                    });\n                } catch (error) {\n                    console.error('DataStore event listener error:', error);\n                }\n            });\n        } catch (error) {\n            console.warn('DataStore: Failed to dispatch change event:', error);\n        }\n    }\n    /**\n     * Add an event listener for DataStore changes\n     * @param {string} type - Event type ('set', 'clear', 'edit', 'deleteItem')\n     * @param {Function} callback - Callback function\n     */ addEventListener(type, callback) {\n        if (typeof callback !== 'function') throw new TypeError('Callback must be a function');\n        if (!this._eventListeners.has(type)) this._eventListeners.set(type, []);\n        this._eventListeners.get(type).push(callback);\n    }\n    /**\n     * Remove an event listener\n     * @param {string} type - Event type\n     * @param {Function} callback - Callback function to remove\n     */ removeEventListener(type, callback) {\n        const listeners = this._eventListeners.get(type);\n        if (listeners) {\n            const index = listeners.indexOf(callback);\n            if (index > -1) listeners.splice(index, 1);\n        }\n    }\n}\n// Make DataStore available globally\nif (typeof window !== 'undefined') window.DataStore = $c369b942a8093473$export$47a0e4800a1fd7dc;\nvar // Export default for easier importing\n$c369b942a8093473$export$2e2bcd8739ae039 = $c369b942a8093473$export$47a0e4800a1fd7dc;\n\n\nclass $54b47fc030b7b21e$var$GroceryApp {\n    constructor(){\n        this.groceryItems = [];\n        this.shoppingSet = new Set();\n        this.uncheckedSet = new Set(); // items in shopping list that are unchecked (struck)\n        this.filteredItems = [];\n        this.currentTab = 'shopping';\n        this.editingItem = null;\n        this.isLoading = true; // track initial loading state for UI messages\n        // DataStore instances\n        this.itemsStore = new (0, $c369b942a8093473$export$47a0e4800a1fd7dc)('groceries.items');\n        this.shoppingStore = new (0, $c369b942a8093473$export$47a0e4800a1fd7dc)('groceries.shopping');\n        this.shoppingStatusStore = new (0, $c369b942a8093473$export$47a0e4800a1fd7dc)('groceries.shoppingStatus');\n        this.init();\n    }\n    async init() {\n        this.isLoading = true;\n        this.renderShoppingList();\n        await this.loadData();\n        await this.loadShopping();\n        await this.loadShoppingStatus();\n        this.isLoading = false;\n        this.setupEventListeners();\n        this.renderCurrentTab();\n        this.hideLoading();\n    }\n    async loadData() {\n        const stored = await this.itemsStore.get(null);\n        if (Array.isArray(stored) && stored.length) this.groceryItems = stored;\n        this.filteredItems = [\n            ...this.groceryItems\n        ];\n        console.log('Loaded data with', this.groceryItems.length, 'items');\n    }\n    async loadShopping() {\n        try {\n            const shopping = await this.shoppingStore.get([]);\n            if (Array.isArray(shopping)) this.shoppingSet = new Set(shopping.map(String));\n        } catch (e) {\n            console.warn('Failed to load shopping list:', e);\n        }\n    }\n    async loadShoppingStatus() {\n        try {\n            const unchecked = await this.shoppingStatusStore.get([]);\n            if (Array.isArray(unchecked)) this.uncheckedSet = new Set(unchecked.map(String));\n        } catch (e) {\n            console.warn('Failed to load shopping status:', e);\n        }\n    }\n    setupEventListeners() {\n        // Modal controls\n        document.getElementById('create-button').addEventListener('click', ()=>this.openCreateModal());\n        document.getElementById('close-modal').addEventListener('click', ()=>this.closeModal());\n        document.getElementById('cancel-modal').addEventListener('click', ()=>this.closeModal());\n        document.getElementById('submit-modal').addEventListener('click', ()=>this.handleModalSubmit());\n        // Add item form\n        const createForm = document.getElementById('add-item-form');\n        createForm.addEventListener('submit', (e)=>this.handleCreateItem(e));\n        // Edit item form\n        const editForm = document.getElementById('edit-item-form');\n        editForm.addEventListener('submit', (e)=>this.handleEditItem(e));\n        // Shopping tab controls\n        // Replace Clear Selected with Clear Shopping List\n        const clearShoppingButton = document.getElementById('clear-shopping');\n        if (clearShoppingButton) clearShoppingButton.addEventListener('click', ()=>this.clearShoppingList());\n        // Store filters\n        document.getElementById('manage-filter-store').addEventListener('change', (e)=>this.filterByStoreManage(e.target.value));\n        // Export items button (Manage tab)\n        const exportBtn = document.getElementById('export-button');\n        if (exportBtn) exportBtn.addEventListener('click', ()=>this.exportItems());\n        // Import items button and file input (Manage tab)\n        const importButton = document.getElementById('import-button');\n        const importFileInput = document.getElementById('import-file');\n        if (importButton && importFileInput) {\n            // Platform detection: Chrome on Android still has quirks opening pickers via FS Access\n            const userAgent = navigator.userAgent || navigator.vendor || window.opera || '';\n            const isAndroid = /Android/i.test(userAgent);\n            const isChrome = /Chrome\\//i.test(userAgent) && !/EdgA\\//i.test(userAgent) && !/OPR\\//i.test(userAgent) && !/SamsungBrowser\\//i.test(userAgent);\n            const isAndroidChrome = isAndroid && isChrome;\n            // Helper using File System Access API when appropriate\n            const tryFileSystemAccessPicker = async (event)=>{\n                const canUseFileSystem = 'showOpenFilePicker' in window && !isAndroidChrome;\n                if (!canUseFileSystem) return false;\n                try {\n                    // Prevent default label->input behavior to avoid double dialogs\n                    event?.preventDefault?.();\n                    const [handle] = await window.showOpenFilePicker({\n                        multiple: false,\n                        types: [\n                            {\n                                description: 'JSON Files',\n                                accept: {\n                                    'application/json': [\n                                        '.json'\n                                    ]\n                                }\n                            }\n                        ]\n                    });\n                    if (!handle) return true; // handled, but nothing chosen\n                    const file = await handle.getFile();\n                    if (file) await this.handleImportFile(file);\n                    return true;\n                } catch (error) {\n                    // If user canceled, do nothing; otherwise fall back\n                    if (error && (error.name === 'AbortError' || error.name === 'NotAllowedError')) return true; // handled\n                    return false;\n                }\n            };\n            const openInputPicker = ()=>{\n                try {\n                    // Clear previous selection so picking the same file triggers change\n                    importFileInput.value = '';\n                    if (typeof importFileInput.showPicker === 'function') importFileInput.showPicker();\n                    else importFileInput.click();\n                } catch  {\n                    importFileInput.click();\n                }\n            };\n            const isLabel = importButton.tagName && importButton.tagName.toLowerCase() === 'label' && importButton.getAttribute('for') === 'import-file';\n            if (!isLabel) {\n                // Non-label button: prefer FS Access (except on Android Chrome), fall back to input APIs\n                importButton.addEventListener('click', async (ev)=>{\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (!handled) openInputPicker();\n                });\n                // Also wire pointerup for better mobile compatibility\n                importButton.addEventListener('pointerup', async (ev)=>{\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (!handled) openInputPicker();\n                });\n            } else {\n                // Label-based control: intercept to use FS Access first when suitable\n                importButton.addEventListener('click', async (ev)=>{\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (handled) return; // FS Access handled or user canceled\n                    // When FS Access not used, let label default fire; also explicitly open for reliability\n                    openInputPicker();\n                });\n                // Touch/pointer fallback to ensure a picker opens on some Android versions\n                importButton.addEventListener('pointerup', async (ev)=>{\n                    // Do not prevent default here unless FS path is taken\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (!handled) openInputPicker();\n                }, {\n                    passive: true\n                });\n                // Keyboard accessibility (Enter/Space)\n                importButton.setAttribute('tabindex', '0');\n                importButton.addEventListener('keydown', async (ev)=>{\n                    if (ev.key === 'Enter' || ev.key === ' ') {\n                        ev.preventDefault();\n                        const handled = await tryFileSystemAccessPicker(ev);\n                        if (!handled) openInputPicker();\n                    }\n                });\n            }\n            // Input-based import fallback\n            importFileInput.addEventListener('change', async (e)=>{\n                const file = e.target.files?.[0];\n                // Reset value so the same file can be selected again next time\n                e.target.value = '';\n                if (file) await this.handleImportFile(file);\n            });\n        }\n        // Listen for tab changes (Pivot CSS handles the switching)\n        document.getElementById('shopping-tab').addEventListener('click', ()=>{\n            this.currentTab = 'shopping';\n            setTimeout(()=>this.renderShoppingList(), 100);\n        });\n        document.getElementById('manage-tab').addEventListener('click', ()=>{\n            this.currentTab = 'manage';\n            setTimeout(()=>this.renderManageTable(), 100);\n        });\n        // Event delegation for dynamically created buttons\n        document.addEventListener('click', (e)=>{\n            const editBtn = e.target.closest('.edit-btn');\n            if (editBtn) {\n                const itemId = editBtn.getAttribute('data-item-id');\n                this.startEdit(itemId);\n                return;\n            }\n            const removeBtn = e.target.closest('.remove-btn');\n            if (removeBtn) {\n                const itemId = removeBtn.getAttribute('data-item-id');\n                this.removeItem(itemId);\n                return;\n            }\n            // Clicking on the Item cell in Manage tab also adds to shopping list\n            const itemCell = e.target.closest('.item-cell');\n            if (itemCell) {\n                // Manage tab behavior\n                if (itemCell.closest('#manage-panel')) {\n                    const itemId = itemCell.getAttribute('data-item-id');\n                    // Toggle: if already in shopping list, remove it; otherwise add it\n                    if (this.shoppingSet.has(String(itemId))) this.removeFromShopping(itemId);\n                    else this.addToShopping(itemId);\n                    return;\n                }\n                // Shopping tab behavior: toggle the item\n                if (itemCell.closest('#shopping-panel')) {\n                    const itemId = itemCell.getAttribute('data-item-id');\n                    // Prefer toggling via the checkbox to reuse native change flow\n                    const checkbox = document.getElementById(`switch-${itemId}`);\n                    if (checkbox) checkbox.click();\n                    else // Fallback: call toggle directly\n                    this.toggleItem(itemId);\n                    return;\n                }\n            }\n        });\n    }\n    renderCurrentTab() {\n        this.renderShoppingList();\n        this.renderManageTable();\n    }\n    handleCreateItem(e) {\n        e.preventDefault();\n        const formData = new FormData(e.target);\n        const newItem = {\n            id: `item-${Date.now()}`,\n            store: formData.get('store'),\n            item: formData.get('item'),\n            price: parseFloat(formData.get('price')) || 0\n        };\n        this.groceryItems.push(newItem);\n        // Persist items\n        this.itemsStore.set(this.groceryItems).catch((err)=>console.error('Failed to persist items:', err));\n        this.applyCurrentFilter();\n        this.renderCurrentTab();\n        // Reset form\n        e.target.reset();\n        // Show success message\n        Toast.show({\n            type: 'success',\n            message: 'Item added successfully!'\n        });\n        // Close modal\n        this.closeModal();\n    }\n    handleEditItem(e) {\n        e.preventDefault();\n        const formData = new FormData(e.target);\n        const itemId = formData.get('id');\n        const itemIndex = this.groceryItems.findIndex((item)=>String(item.id) === String(itemId));\n        if (itemIndex !== -1) {\n            this.groceryItems[itemIndex] = {\n                id: itemId,\n                store: formData.get('store'),\n                item: formData.get('item'),\n                price: parseFloat(formData.get('price')) || 0\n            };\n            this.applyCurrentFilter();\n            this.renderCurrentTab();\n            // Persist items\n            this.itemsStore.set(this.groceryItems).catch((err)=>console.error('Failed to persist items:', err));\n            Toast.show({\n                type: 'success',\n                message: 'Item updated successfully!'\n            });\n            // Close modal\n            this.closeModal();\n        }\n    }\n    startEdit(itemId) {\n        const item = this.groceryItems.find((item)=>String(item.id) === String(itemId));\n        if (!item) return;\n        this.editingItem = itemId;\n        // Populate edit form\n        document.getElementById('edit-item-id').value = item.id;\n        document.getElementById('edit-store-select').value = item.store;\n        document.getElementById('edit-item-name').value = item.item;\n        document.getElementById('edit-item-price').value = item.price;\n        // Open modal in edit mode\n        this.openEditModal();\n    }\n    cancelEdit() {\n        this.editingItem = null;\n        // Reset edit form\n        document.getElementById('edit-item-form').reset();\n        // Close modal\n        this.closeModal();\n    }\n    filterByStore(store) {\n        if (!store) this.filteredItems = [\n            ...this.groceryItems\n        ];\n        else this.filteredItems = this.groceryItems.filter((item)=>item.store === store);\n        this.renderShoppingList();\n    }\n    filterByStoreManage(store) {\n        if (!store) this.filteredItems = [\n            ...this.groceryItems\n        ];\n        else this.filteredItems = this.groceryItems.filter((item)=>item.store === store);\n        this.renderManageTable();\n    }\n    applyCurrentFilter() {\n        if (this.currentTab === 'shopping') {\n            const filterSelect = document.getElementById('filter-store');\n            const currentFilter = filterSelect.value;\n            this.filterByStore(currentFilter);\n        } else {\n            const filterSelect = document.getElementById('manage-filter-store');\n            const currentFilter = filterSelect.value;\n            this.filterByStoreManage(currentFilter);\n        }\n    }\n    renderShoppingList() {\n        const tbody = document.getElementById('shopping-tbody');\n        // Build the list from shoppingSet only\n        const toRender = this.groceryItems.filter((item)=>this.shoppingSet.has(String(item.id)));\n        if (tbody) {\n            // Loading state\n            if (this.isLoading) {\n                tbody.innerHTML = `\n                    <tr>\n                        <td colspan=\"4\" style=\"text-align:center; color: var(--pico-muted-color);\">Loading grocery items...</td>\n                    </tr>\n                `;\n                return;\n            }\n            // Empty state\n            if (toRender.length === 0) {\n                tbody.innerHTML = `\n                    <tr>\n                        <td colspan=\"4\" style=\"text-align:center; color: var(--pico-muted-color);\">\n                            No items found. Add some items in the Manage tab to get started!\n                        </td>\n                    </tr>\n                `;\n                return;\n            }\n            tbody.innerHTML = toRender.map((item)=>{\n                let badge = 'warning';\n                switch(item.store.toLowerCase()){\n                    case 'auchan':\n                        badge = 'danger';\n                        break;\n                    case 'inter':\n                        badge = 'success';\n                        break;\n                    case 'picard':\n                        badge = 'info';\n                        break;\n                }\n                const isUnchecked = this.uncheckedSet.has(String(item.id));\n                return `\n                    <tr class=\"shopping-item ${isUnchecked ? 'struck' : ''}\" data-item-id=\"${item.id}\">\n                        <td class=\"actions\"><input type=\"checkbox\" role=\"switch\" id=\"switch-${item.id}\" ${!isUnchecked ? 'checked' : ''} onchange=\"groceryApp.toggleItem('${item.id}')\"></td>\n                        <td class=\"item-cell clickable-item\" data-item-id=\"${item.id}\">${this.escapeHtml(item.item)}</td>\n                        <td class=\"price\">\\u{20AC}${item.price.toFixed(2)}</td>\n                    </tr>\n                `;\n            }).join('');\n        }\n    }\n    renderManageTable() {\n        const tbody = document.getElementById('grocery-tbody');\n        if (this.filteredItems.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"4\" style=\"text-align: center; color: var(--pico-muted-color);\">No items found</td></tr>';\n            return;\n        }\n        tbody.innerHTML = this.filteredItems.map((item)=>{\n            let badge = 'warning';\n            switch(item.store.toLowerCase()){\n                case 'auchan':\n                    badge = 'danger';\n                    break;\n                case 'inter':\n                    badge = 'success';\n                    break;\n                case 'picard':\n                    badge = 'info';\n                    break;\n            }\n            const inShopping = this.shoppingSet.has(String(item.id));\n            return `\n                <tr data-item-id=\"${item.id}\">\n                    <td>\n                        <small role=\"status\" class=\"${badge}\">${item.store}</small>\n                    </td>\n                    <td class=\"item-cell clickable-item ${inShopping ? 'in-shopping-list' : ''}\" data-item-id=\"${item.id}\" title=\"${inShopping ? 'Remove from shopping list' : 'Add to shopping list'}\">${this.escapeHtml(item.item)}</td>\n                    <td class=\"price\">\\u{20AC}${item.price.toFixed(2)}</td>\n                    <td class=\"actions\">\n                        <ul role=\"toolbar\">\n                            <li role=\"menuitem\">\n                                <a role=\"button\" class=\"edit-btn\" data-item-id=\"${item.id}\" title=\"Edit item\">\n                                    <svg width=\"16\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\"><!-- warning -->\n                                        <circle cx=\"8\" cy=\"8\" r=\"8\" fill=\"#ffbf00\"></circle>\n                                    </svg>\n                                </a>\n                            </li>\n                            <li role=\"menuitem\">\n                                <a role=\"button\" class=\"remove-btn\" data-item-id=\"${item.id}\" title=\"Remove item\">\n                                    <svg width=\"16\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\"><!-- danger -->\n                                        <circle cx=\"8\" cy=\"8\" r=\"8\" fill=\"#ee402e\"></circle>\n                                    </svg>\n                                </a>\n                            </li>\n                        </ul>\n                    </td>\n                </tr>\n            `;\n        }).join('');\n    }\n    addToShopping(itemId) {\n        if (this.shoppingSet.has(itemId)) {\n            Toast.show({\n                type: 'danger',\n                message: 'Item already in shopping list'\n            });\n            // Also ensure UI reflects current state\n            this.renderManageTable();\n            return;\n        }\n        this.shoppingSet.add(itemId);\n        this.shoppingStore.set([\n            ...this.shoppingSet\n        ]).catch((err)=>console.error('Failed to persist shopping list:', err));\n        // Default to checked when added (i.e., not in unchecked set)\n        if (this.uncheckedSet.delete(itemId)) this.shoppingStatusStore.set([\n            ...this.uncheckedSet\n        ]).catch((err)=>console.error('Failed to persist shopping status:', err));\n        Toast.show({\n            type: 'success',\n            message: 'Added to shopping list'\n        });\n        if (this.currentTab === 'shopping') this.renderShoppingList();\n        // Update Manage table highlighting\n        this.renderManageTable();\n    }\n    removeFromShopping(itemId) {\n        if (!this.shoppingSet.has(itemId)) // Nothing to do\n        return;\n        this.shoppingSet.delete(itemId);\n        this.shoppingStore.set([\n            ...this.shoppingSet\n        ]).catch((err)=>console.error('Failed to persist shopping list:', err));\n        // Also remove any unchecked status associated with this item\n        if (this.uncheckedSet.delete(itemId)) this.shoppingStatusStore.set([\n            ...this.uncheckedSet\n        ]).catch((err)=>console.error('Failed to persist shopping status:', err));\n        Toast.show({\n            type: 'info',\n            message: 'Removed from shopping list'\n        });\n        if (this.currentTab === 'shopping') this.renderShoppingList();\n        // Update Manage table highlighting\n        this.renderManageTable();\n    }\n    toggleItem(itemId) {\n        // Toggle checked/unchecked for shopping list item and persist\n        const id = String(itemId);\n        const row = document.querySelector(`[data-item-id=\"${id}\"]`);\n        const checkbox = document.getElementById(`switch-${id}`);\n        const isChecked = !!checkbox?.checked;\n        if (isChecked) {\n            // Checked => remove from unchecked set (no strike)\n            this.uncheckedSet.delete(id);\n            row?.classList.remove('struck');\n        } else {\n            // Unchecked => add to unchecked set (strike)\n            this.uncheckedSet.add(id);\n            row?.classList.add('struck');\n        }\n        // Persist unchecked set status\n        this.shoppingStatusStore.set([\n            ...this.uncheckedSet\n        ]).catch((err)=>console.error('Failed to persist shopping status:', err));\n        // Also update the text decoration immediately for UX\n        const nameCell = row?.querySelector('td:nth-child(2)');\n        if (nameCell) {\n            if (isChecked) {\n                nameCell.style.textDecoration = '';\n                nameCell.style.opacity = '';\n            } else {\n                nameCell.style.textDecoration = 'line-through';\n                nameCell.style.opacity = '0.6';\n            }\n        }\n        // Re-render to apply ordering so checked items move to the end\n        if (this.currentTab === 'shopping') this.renderShoppingList();\n    }\n    removeItem(itemId) {\n        this.groceryItems = this.groceryItems.filter((item)=>String(item.id) !== String(itemId));\n        // Also remove from shopping list if present\n        if (this.shoppingSet.delete(itemId)) this.shoppingStore.set([\n            ...this.shoppingSet\n        ]).catch((err)=>console.error('Failed to persist shopping list:', err));\n        // Remove strike status tracking if present\n        if (this.uncheckedSet.delete(itemId)) this.shoppingStatusStore.set([\n            ...this.uncheckedSet\n        ]).catch((err)=>console.error('Failed to persist shopping status:', err));\n        this.applyCurrentFilter();\n        this.renderCurrentTab();\n        // Persist items\n        this.itemsStore.set(this.groceryItems).catch((err)=>console.error('Failed to persist items:', err));\n        Toast.show({\n            type: 'success',\n            message: 'Item removed successfully!'\n        });\n    }\n    clearSelected() {\n        this.selectedItems.clear();\n        this.renderShoppingList();\n        // Persist selection\n        this.selectedStore.set([]).catch((err)=>console.error('Failed to persist selection:', err));\n        Toast.show({\n            type: 'info',\n            message: 'Selection cleared!'\n        });\n    }\n    updateSelectedCount() {\n        // With the new UI, we display a static label for the clear shopping button\n        const clearBtn = document.getElementById('clear-shopping');\n        if (clearBtn) clearBtn.textContent = 'Clear Shopping List';\n    }\n    hideLoading() {\n        const loading = document.getElementById('loading');\n        if (loading && loading.style) loading.style.display = 'none';\n    }\n    showError(message) {\n        this.hideLoading();\n        const tbody = document.getElementById('shopping-tbody');\n        if (tbody) tbody.innerHTML = `\n                <tr>\n                    <td colspan=\"4\" style=\"text-align:center; color: var(--pico-del-color);\">Error: ${this.escapeHtml(message)}</td>\n                </tr>\n            `;\n    }\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n    // Modal methods\n    openCreateModal() {\n        const modal = document.getElementById('item-modal');\n        const modalTitle = document.getElementById('modal-title');\n        const createForm = document.getElementById('add-item-form');\n        const editForm = document.getElementById('edit-item-form');\n        const submitBtn = document.getElementById('submit-modal');\n        // Reset editing state\n        this.editingItem = null;\n        // Configure modal for adding\n        modalTitle.textContent = 'Create Item';\n        createForm.style.display = 'block';\n        editForm.style.display = 'none';\n        submitBtn.textContent = \"\\uD83D\\uDCBE Add Item\";\n        // Reset add form\n        createForm.reset();\n        // Open modal\n        modal.showModal();\n    }\n    openEditModal() {\n        const modal = document.getElementById('item-modal');\n        const modalTitle = document.getElementById('modal-title');\n        const createForm = document.getElementById('add-item-form');\n        const editForm = document.getElementById('edit-item-form');\n        const submitBtn = document.getElementById('submit-modal');\n        // Configure modal for editing\n        modalTitle.textContent = 'Edit Item';\n        createForm.style.display = 'none';\n        editForm.style.display = 'block';\n        submitBtn.textContent = \"\\uD83D\\uDCBE Update Item\";\n        // Open modal\n        modal.showModal();\n    }\n    closeModal() {\n        const modal = document.getElementById('item-modal');\n        const createForm = document.getElementById('add-item-form');\n        const editForm = document.getElementById('edit-item-form');\n        // Reset forms\n        createForm.reset();\n        editForm.reset();\n        // Reset editing state\n        this.editingItem = null;\n        // Close modal\n        modal.close();\n    }\n    handleModalSubmit() {\n        if (this.editingItem) {\n            // Submit edit form\n            const editForm = document.getElementById('edit-item-form');\n            const event = new Event('submit', {\n                bubbles: true,\n                cancelable: true\n            });\n            editForm.dispatchEvent(event);\n        } else {\n            // Submit add form\n            const createForm = document.getElementById('add-item-form');\n            const event = new Event('submit', {\n                bubbles: true,\n                cancelable: true\n            });\n            createForm.dispatchEvent(event);\n        }\n    }\n    clearShoppingList() {\n        // Empty the shopping list and associated unchecked statuses\n        if (this.shoppingSet.size === 0) {\n            Toast.show({\n                type: 'danger',\n                message: 'Shopping list is already empty'\n            });\n            return;\n        }\n        this.shoppingSet.clear();\n        this.uncheckedSet.clear();\n        // Persist\n        this.shoppingStore.set([]).catch((err)=>console.error('Failed to persist shopping list:', err));\n        this.shoppingStatusStore.set([]).catch((err)=>console.error('Failed to persist shopping status:', err));\n        // Re-render\n        if (this.currentTab === 'shopping') this.renderShoppingList();\n        Toast.show({\n            type: 'success',\n            message: 'Shopping list cleared'\n        });\n    }\n    exportItems() {\n        try {\n            // Ensure we export the complete, current item list\n            const data = this.groceryItems.map(({ id: id, store: store, item: item, price: price })=>({\n                    id: id,\n                    store: store,\n                    item: item,\n                    price: price\n                }));\n            const json = JSON.stringify(data, null, 2);\n            const blob = new Blob([\n                json\n            ], {\n                type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n            const now = new Date();\n            const pad = (n)=>String(n).padStart(2, '0');\n            const fileName = `groceries-items-${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = fileName;\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n            URL.revokeObjectURL(url);\n            Toast.show({\n                type: 'success',\n                message: 'Item list exported'\n            });\n        } catch (err) {\n            console.error('Failed to export items:', err);\n            Toast.error('Failed to export items');\n        }\n    }\n    async handleImportFile(file) {\n        try {\n            if (!(file instanceof File)) {\n                Toast.error('No file selected');\n                return;\n            }\n            const text = await new Promise((resolve, reject)=>{\n                const reader = new FileReader();\n                reader.onload = ()=>resolve(String(reader.result || ''));\n                reader.onerror = ()=>reject(reader.error || new Error('Failed to read file'));\n                reader.readAsText(file);\n            });\n            let data;\n            try {\n                data = JSON.parse(text);\n            } catch (parseErr) {\n                console.error('Invalid JSON file:', parseErr);\n                Toast.error('Invalid JSON file');\n                return;\n            }\n            if (!Array.isArray(data)) {\n                Toast.error('JSON must be an array of items');\n                return;\n            }\n            // Build indexes for fast checks\n            const existingIdSet = new Set(this.groceryItems.map((it)=>String(it.id)));\n            const existingKeySet = new Set(this.groceryItems.map((it)=>`${String(it.store).trim().toLowerCase()}|${String(it.item).trim().toLowerCase()}`));\n            const toAdd = [];\n            let skippedInvalid = 0;\n            let skippedDuplicates = 0;\n            let counter = 0;\n            const makeUniqueId = ()=>{\n                let id;\n                do id = `item-${Date.now()}-${counter++}`;\n                while (existingIdSet.has(id));\n                existingIdSet.add(id);\n                return id;\n            };\n            for (const raw of data){\n                // Basic shape check and normalization (accepts variations in key case/names)\n                const store = raw?.store ?? raw?.Store ?? raw?.STORE;\n                const name = raw?.item ?? raw?.name ?? raw?.Item ?? raw?.ITEM;\n                const priceRaw = raw?.price ?? raw?.Price ?? raw?.PRICE;\n                if (!store || !name) {\n                    skippedInvalid++;\n                    continue;\n                }\n                const item = String(name).trim();\n                const storeStr = String(store).trim();\n                // Parse price to number (default 0)\n                let price = Number(priceRaw);\n                if (!isFinite(price)) price = 0;\n                // Deduplicate by (store,item) pair\n                const key = `${storeStr.toLowerCase()}|${item.toLowerCase()}`;\n                if (existingKeySet.has(key)) {\n                    skippedDuplicates++;\n                    continue;\n                }\n                // Also prevent duplicates within the current batch\n                if (toAdd.some((x)=>`${x.store.toLowerCase()}|${x.item.toLowerCase()}` === key)) {\n                    skippedDuplicates++;\n                    continue;\n                }\n                // Ensure ID is present and unique\n                let id = raw?.id != null ? String(raw.id) : '';\n                if (!id || existingIdSet.has(id)) id = makeUniqueId();\n                else existingIdSet.add(id);\n                toAdd.push({\n                    id: id,\n                    store: storeStr,\n                    item: item,\n                    price: price\n                });\n                existingKeySet.add(key);\n            }\n            if (toAdd.length === 0) {\n                if (skippedInvalid > 0) Toast.show({\n                    type: 'warning',\n                    message: 'No items imported: invalid or duplicate entries'\n                });\n                else Toast.show({\n                    type: 'info',\n                    message: 'No new items to import'\n                });\n                return;\n            }\n            // Merge and persist\n            this.groceryItems.push(...toAdd);\n            await this.itemsStore.set(this.groceryItems);\n            // Reapply filter and re-render manage table\n            this.applyCurrentFilter();\n            this.renderCurrentTab();\n            const details = [];\n            if (skippedDuplicates) details.push(`${skippedDuplicates} duplicate(s) skipped`);\n            if (skippedInvalid) details.push(`${skippedInvalid} invalid item(s) skipped`);\n            const suffix = details.length ? ` (${details.join(', ')})` : '';\n            Toast.show({\n                type: 'success',\n                message: `Imported ${toAdd.length} item(s)${suffix}`\n            });\n        } catch (err) {\n            console.error('Failed to import items:', err);\n            Toast.error('Failed to import items');\n        }\n    }\n}\n// Initialize the app when DOM is loaded\nwindow.groceryApp = null;\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    window.groceryApp = new $54b47fc030b7b21e$var$GroceryApp();\n});\n\n\n//# sourceMappingURL=groceries.50ac3565.js.map\n","// Grocery List App - Main JavaScript\nimport { DataStore } from './dataStore.js';\nclass GroceryApp {\n    constructor() {\n        this.groceryItems = [];\n        this.shoppingSet = new Set();\n        this.uncheckedSet = new Set(); // items in shopping list that are unchecked (struck)\n        this.filteredItems = [];\n        this.currentTab = 'shopping';\n        this.editingItem = null;\n        this.isLoading = true; // track initial loading state for UI messages\n\n        // DataStore instances\n        this.itemsStore = new DataStore('groceries.items');\n        this.shoppingStore = new DataStore('groceries.shopping');\n        this.shoppingStatusStore = new DataStore('groceries.shoppingStatus');\n\n        this.init();\n    }\n\n    async init() {\n        this.isLoading = true;\n        this.renderShoppingList();\n\n        await this.loadData();\n        await this.loadShopping();\n        await this.loadShoppingStatus();\n        this.isLoading = false;\n        this.setupEventListeners();\n        this.renderCurrentTab();\n        this.hideLoading();\n    }\n\n    async loadData() {\n        const stored = await this.itemsStore.get(null);\n        if (Array.isArray(stored) && stored.length) {\n            this.groceryItems = stored;\n        }\n        this.filteredItems = [...this.groceryItems];\n        console.log('Loaded data with', this.groceryItems.length, 'items');\n    }\n\n    async loadShopping() {\n        try {\n            const shopping = await this.shoppingStore.get([]);\n            if (Array.isArray(shopping)) {\n                this.shoppingSet = new Set(shopping.map(String));\n            }\n        } catch (e) {\n            console.warn('Failed to load shopping list:', e);\n        }\n    }\n\n    async loadShoppingStatus() {\n        try {\n            const unchecked = await this.shoppingStatusStore.get([]);\n            if (Array.isArray(unchecked)) {\n                this.uncheckedSet = new Set(unchecked.map(String));\n            }\n        } catch (e) {\n            console.warn('Failed to load shopping status:', e);\n        }\n    }\n\n    setupEventListeners() {\n        // Modal controls\n        document.getElementById('create-button').addEventListener('click', () => this.openCreateModal());\n        document.getElementById('close-modal').addEventListener('click', () => this.closeModal());\n        document.getElementById('cancel-modal').addEventListener('click', () => this.closeModal());\n        document.getElementById('submit-modal').addEventListener('click', () => this.handleModalSubmit());\n\n        // Add item form\n        const createForm = document.getElementById('add-item-form');\n        createForm.addEventListener('submit', (e) => this.handleCreateItem(e));\n\n        // Edit item form\n        const editForm = document.getElementById('edit-item-form');\n        editForm.addEventListener('submit', (e) => this.handleEditItem(e));\n\n        // Shopping tab controls\n        // Replace Clear Selected with Clear Shopping List\n        const clearShoppingButton = document.getElementById('clear-shopping');\n        if (clearShoppingButton) {\n            clearShoppingButton.addEventListener('click', () => this.clearShoppingList());\n        }\n\n        // Store filters\n        document.getElementById('manage-filter-store').addEventListener('change', (e) => this.filterByStoreManage(e.target.value));\n\n        // Export items button (Manage tab)\n        const exportBtn = document.getElementById('export-button');\n        if (exportBtn) {\n            exportBtn.addEventListener('click', () => this.exportItems());\n        }\n\n        // Import items button and file input (Manage tab)\n        const importButton = document.getElementById('import-button');\n        const importFileInput = document.getElementById('import-file');\n        if (importButton && importFileInput) {\n            // Platform detection: Chrome on Android still has quirks opening pickers via FS Access\n            const userAgent = navigator.userAgent || navigator.vendor || window.opera || '';\n            const isAndroid = /Android/i.test(userAgent);\n            const isChrome = /Chrome\\//i.test(userAgent) && !/EdgA\\//i.test(userAgent) && !/OPR\\//i.test(userAgent) && !/SamsungBrowser\\//i.test(userAgent);\n            const isAndroidChrome = isAndroid && isChrome;\n\n            // Helper using File System Access API when appropriate\n            const tryFileSystemAccessPicker = async (event) => {\n                const canUseFileSystem = ('showOpenFilePicker' in window) && !isAndroidChrome;\n                if (!canUseFileSystem) return false;\n                try {\n                    // Prevent default label->input behavior to avoid double dialogs\n                    event?.preventDefault?.();\n                    const [handle] = await window.showOpenFilePicker({\n                        multiple: false,\n                        types: [{\n                            description: 'JSON Files',\n                            accept: { 'application/json': ['.json'] }\n                        }]\n                    });\n                    if (!handle) return true; // handled, but nothing chosen\n                    const file = await handle.getFile();\n                    if (file) await this.handleImportFile(file);\n                    return true;\n                } catch (error) {\n                    // If user canceled, do nothing; otherwise fall back\n                    if (error && (error.name === 'AbortError' || error.name === 'NotAllowedError')) return true; // handled\n                    return false;\n                }\n            };\n\n            const openInputPicker = () => {\n                try {\n                    // Clear previous selection so picking the same file triggers change\n                    importFileInput.value = '';\n                    if (typeof importFileInput.showPicker === 'function') {\n                        importFileInput.showPicker();\n                    } else {\n                        importFileInput.click();\n                    }\n                } catch {\n                    importFileInput.click();\n                }\n            };\n\n            const isLabel = importButton.tagName && importButton.tagName.toLowerCase() === 'label' && importButton.getAttribute('for') === 'import-file';\n\n            if (!isLabel) {\n                // Non-label button: prefer FS Access (except on Android Chrome), fall back to input APIs\n                importButton.addEventListener('click', async (ev) => {\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (!handled) openInputPicker();\n                });\n                // Also wire pointerup for better mobile compatibility\n                importButton.addEventListener('pointerup', async (ev) => {\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (!handled) openInputPicker();\n                });\n            } else {\n                // Label-based control: intercept to use FS Access first when suitable\n                importButton.addEventListener('click', async (ev) => {\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (handled) return; // FS Access handled or user canceled\n                    // When FS Access not used, let label default fire; also explicitly open for reliability\n                    openInputPicker();\n                });\n\n                // Touch/pointer fallback to ensure a picker opens on some Android versions\n                importButton.addEventListener('pointerup', async (ev) => {\n                    // Do not prevent default here unless FS path is taken\n                    const handled = await tryFileSystemAccessPicker(ev);\n                    if (!handled) openInputPicker();\n                }, { passive: true });\n\n                // Keyboard accessibility (Enter/Space)\n                importButton.setAttribute('tabindex', '0');\n                importButton.addEventListener('keydown', async (ev) => {\n                    if (ev.key === 'Enter' || ev.key === ' ') {\n                        ev.preventDefault();\n                        const handled = await tryFileSystemAccessPicker(ev);\n                        if (!handled) openInputPicker();\n                    }\n                });\n            }\n\n            // Input-based import fallback\n            importFileInput.addEventListener('change', async (e) => {\n                const file = e.target.files?.[0];\n                // Reset value so the same file can be selected again next time\n                e.target.value = '';\n                if (file) {\n                    await this.handleImportFile(file);\n                }\n            });\n        }\n\n        // Listen for tab changes (Pivot CSS handles the switching)\n        document.getElementById('shopping-tab').addEventListener('click', () => {\n            this.currentTab = 'shopping';\n            setTimeout(() => this.renderShoppingList(), 100);\n        });\n\n        document.getElementById('manage-tab').addEventListener('click', () => {\n            this.currentTab = 'manage';\n            setTimeout(() => this.renderManageTable(), 100);\n        });\n\n        // Event delegation for dynamically created buttons\n        document.addEventListener('click', (e) => {\n            const editBtn = e.target.closest('.edit-btn');\n            if (editBtn) {\n                const itemId = editBtn.getAttribute('data-item-id');\n                this.startEdit(itemId);\n                return;\n            }\n            const removeBtn = e.target.closest('.remove-btn');\n            if (removeBtn) {\n                const itemId = removeBtn.getAttribute('data-item-id');\n                this.removeItem(itemId);\n                return;\n            }\n            // Clicking on the Item cell in Manage tab also adds to shopping list\n            const itemCell = e.target.closest('.item-cell');\n            if (itemCell) {\n                // Manage tab behavior\n                if (itemCell.closest('#manage-panel')) {\n                    const itemId = itemCell.getAttribute('data-item-id');\n                    // Toggle: if already in shopping list, remove it; otherwise add it\n                    if (this.shoppingSet.has(String(itemId))) {\n                        this.removeFromShopping(itemId);\n                    } else {\n                        this.addToShopping(itemId);\n                    }\n                    return;\n                }\n                // Shopping tab behavior: toggle the item\n                if (itemCell.closest('#shopping-panel')) {\n                    const itemId = itemCell.getAttribute('data-item-id');\n                    // Prefer toggling via the checkbox to reuse native change flow\n                    const checkbox = document.getElementById(`switch-${itemId}`);\n                    if (checkbox) {\n                        checkbox.click();\n                    } else {\n                        // Fallback: call toggle directly\n                        this.toggleItem(itemId);\n                    }\n                    return;\n                }\n            }\n        });\n    }\n\n    renderCurrentTab() {\n        this.renderShoppingList();\n        this.renderManageTable();\n    }\n\n    handleCreateItem(e) {\n        e.preventDefault();\n\n        const formData = new FormData(e.target);\n        const newItem = {\n            id: `item-${Date.now()}`,\n            store: formData.get('store'),\n            item: formData.get('item'),\n            price: parseFloat(formData.get('price')) || 0\n        };\n\n        this.groceryItems.push(newItem);\n        // Persist items\n        this.itemsStore.set(this.groceryItems).catch(err => console.error('Failed to persist items:', err));\n        this.applyCurrentFilter();\n        this.renderCurrentTab();\n        \n        // Reset form\n        e.target.reset();\n\n        // Show success message\n        Toast.show({type: 'success', message: 'Item added successfully!'});\n\n        // Close modal\n        this.closeModal();\n    }\n\n    handleEditItem(e) {\n        e.preventDefault();\n\n        const formData = new FormData(e.target);\n        const itemId = formData.get('id');\n        const itemIndex = this.groceryItems.findIndex(item => String(item.id) === String(itemId));\n\n        if (itemIndex !== -1) {\n            this.groceryItems[itemIndex] = {\n                id: itemId,\n                store: formData.get('store'),\n                item: formData.get('item'),\n                price: parseFloat(formData.get('price')) || 0\n            };\n\n            this.applyCurrentFilter();\n            this.renderCurrentTab();\n            // Persist items\n            this.itemsStore.set(this.groceryItems).catch(err => console.error('Failed to persist items:', err));\n            Toast.show({type: 'success', message: 'Item updated successfully!'});\n\n            // Close modal\n            this.closeModal();\n        }\n    }\n\n    startEdit(itemId) {\n        const item = this.groceryItems.find(item => String(item.id) === String(itemId));\n        if (!item) return;\n\n        this.editingItem = itemId;\n\n        // Populate edit form\n        document.getElementById('edit-item-id').value = item.id;\n        document.getElementById('edit-store-select').value = item.store;\n        document.getElementById('edit-item-name').value = item.item;\n        document.getElementById('edit-item-price').value = item.price;\n\n        // Open modal in edit mode\n        this.openEditModal();\n    }\n\n    cancelEdit() {\n        this.editingItem = null;\n\n        // Reset edit form\n        document.getElementById('edit-item-form').reset();\n\n        // Close modal\n        this.closeModal();\n    }\n\n    filterByStore(store) {\n        if (!store) {\n            this.filteredItems = [...this.groceryItems];\n        } else {\n            this.filteredItems = this.groceryItems.filter(item => item.store === store);\n        }\n        this.renderShoppingList();\n    }\n\n    filterByStoreManage(store) {\n        if (!store) {\n            this.filteredItems = [...this.groceryItems];\n        } else {\n            this.filteredItems = this.groceryItems.filter(item => item.store === store);\n        }\n        this.renderManageTable();\n    }\n\n    applyCurrentFilter() {\n        if (this.currentTab === 'shopping') {\n            const filterSelect = document.getElementById('filter-store');\n            const currentFilter = filterSelect.value;\n            this.filterByStore(currentFilter);\n        } else {\n            const filterSelect = document.getElementById('manage-filter-store');\n            const currentFilter = filterSelect.value;\n            this.filterByStoreManage(currentFilter);\n        }\n    }\n\n    renderShoppingList() {\n        const tbody = document.getElementById('shopping-tbody');\n\n        // Build the list from shoppingSet only\n        const toRender = this.groceryItems.filter(item => this.shoppingSet.has(String(item.id)));\n\n        if (tbody) {\n            // Loading state\n            if (this.isLoading) {\n                tbody.innerHTML = `\n                    <tr>\n                        <td colspan=\"4\" style=\"text-align:center; color: var(--pico-muted-color);\">Loading grocery items...</td>\n                    </tr>\n                `;\n                return;\n            }\n\n            // Empty state\n            if (toRender.length === 0) {\n                tbody.innerHTML = `\n                    <tr>\n                        <td colspan=\"4\" style=\"text-align:center; color: var(--pico-muted-color);\">\n                            No items found. Add some items in the Manage tab to get started!\n                        </td>\n                    </tr>\n                `;\n                return;\n            }\n\n            tbody.innerHTML = toRender.map(item => {\n                let badge = 'warning';\n                switch (item.store.toLowerCase()) {\n                    case 'auchan':\n                        badge = 'danger';\n                        break;\n                    case 'inter':\n                        badge = 'success';\n                        break;\n                    case 'picard':\n                        badge = 'info';\n                        break;\n                }\n                const isUnchecked = this.uncheckedSet.has(String(item.id));\n                return `\n                    <tr class=\"shopping-item ${isUnchecked ? 'struck' : ''}\" data-item-id=\"${item.id}\">\n                        <td class=\"actions\"><input type=\"checkbox\" role=\"switch\" id=\"switch-${item.id}\" ${!isUnchecked ? 'checked' : ''} onchange=\"groceryApp.toggleItem('${item.id}')\"></td>\n                        <td class=\"item-cell clickable-item\" data-item-id=\"${item.id}\">${this.escapeHtml(item.item)}</td>\n                        <td class=\"price\">€${item.price.toFixed(2)}</td>\n                    </tr>\n                `;\n            }).join('');\n        }\n    }\n\n    renderManageTable() {\n        const tbody = document.getElementById('grocery-tbody');\n\n        if (this.filteredItems.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"4\" style=\"text-align: center; color: var(--pico-muted-color);\">No items found</td></tr>';\n            return;\n        }\n\n        tbody.innerHTML = this.filteredItems.map(item => {\n            let badge = 'warning';\n            switch (item.store.toLowerCase()) {\n                case 'auchan':\n                    badge = 'danger';\n                    break;\n                case 'inter':\n                    badge = 'success';\n                    break;\n                case 'picard':\n                    badge = 'info';\n                    break;\n            }\n            const inShopping = this.shoppingSet.has(String(item.id));\n            return `\n                <tr data-item-id=\"${item.id}\">\n                    <td>\n                        <small role=\"status\" class=\"${badge}\">${item.store}</small>\n                    </td>\n                    <td class=\"item-cell clickable-item ${inShopping ? 'in-shopping-list' : ''}\" data-item-id=\"${item.id}\" title=\"${inShopping ? 'Remove from shopping list' : 'Add to shopping list'}\">${this.escapeHtml(item.item)}</td>\n                    <td class=\"price\">€${item.price.toFixed(2)}</td>\n                    <td class=\"actions\">\n                        <ul role=\"toolbar\">\n                            <li role=\"menuitem\">\n                                <a role=\"button\" class=\"edit-btn\" data-item-id=\"${item.id}\" title=\"Edit item\">\n                                    <svg width=\"16\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\"><!-- warning -->\n                                        <circle cx=\"8\" cy=\"8\" r=\"8\" fill=\"#ffbf00\"></circle>\n                                    </svg>\n                                </a>\n                            </li>\n                            <li role=\"menuitem\">\n                                <a role=\"button\" class=\"remove-btn\" data-item-id=\"${item.id}\" title=\"Remove item\">\n                                    <svg width=\"16\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\"><!-- danger -->\n                                        <circle cx=\"8\" cy=\"8\" r=\"8\" fill=\"#ee402e\"></circle>\n                                    </svg>\n                                </a>\n                            </li>\n                        </ul>\n                    </td>\n                </tr>\n            `;\n        }).join('');\n    }\n\n    addToShopping(itemId) {\n        if (this.shoppingSet.has(itemId)) {\n            Toast.show({type: 'danger', message: 'Item already in shopping list'});\n            // Also ensure UI reflects current state\n            this.renderManageTable();\n            return;\n        }\n        this.shoppingSet.add(itemId);\n        this.shoppingStore.set([...this.shoppingSet]).catch(err => console.error('Failed to persist shopping list:', err));\n        // Default to checked when added (i.e., not in unchecked set)\n        if (this.uncheckedSet.delete(itemId)) {\n            this.shoppingStatusStore.set([...this.uncheckedSet]).catch(err => console.error('Failed to persist shopping status:', err));\n        }\n        Toast.show({type: 'success', message: 'Added to shopping list'});\n        if (this.currentTab === 'shopping') {\n            this.renderShoppingList();\n        }\n        // Update Manage table highlighting\n        this.renderManageTable();\n    }\n\n    removeFromShopping(itemId) {\n        if (!this.shoppingSet.has(itemId)) {\n            // Nothing to do\n            return;\n        }\n        this.shoppingSet.delete(itemId);\n        this.shoppingStore.set([...this.shoppingSet]).catch(err => console.error('Failed to persist shopping list:', err));\n        // Also remove any unchecked status associated with this item\n        if (this.uncheckedSet.delete(itemId)) {\n            this.shoppingStatusStore.set([...this.uncheckedSet]).catch(err => console.error('Failed to persist shopping status:', err));\n        }\n        Toast.show({type: 'info', message: 'Removed from shopping list'});\n        if (this.currentTab === 'shopping') {\n            this.renderShoppingList();\n        }\n        // Update Manage table highlighting\n        this.renderManageTable();\n    }\n\n    toggleItem(itemId) {\n        // Toggle checked/unchecked for shopping list item and persist\n        const id = String(itemId);\n        const row = document.querySelector(`[data-item-id=\"${id}\"]`);\n        const checkbox = document.getElementById(`switch-${id}`);\n        const isChecked = !!checkbox?.checked;\n\n        if (isChecked) {\n            // Checked => remove from unchecked set (no strike)\n            this.uncheckedSet.delete(id);\n            row?.classList.remove('struck');\n        } else {\n            // Unchecked => add to unchecked set (strike)\n            this.uncheckedSet.add(id);\n            row?.classList.add('struck');\n        }\n\n        // Persist unchecked set status\n        this.shoppingStatusStore.set([...this.uncheckedSet]).catch(err => console.error('Failed to persist shopping status:', err));\n\n        // Also update the text decoration immediately for UX\n        const nameCell = row?.querySelector('td:nth-child(2)');\n        if (nameCell) {\n            if (isChecked) {\n                nameCell.style.textDecoration = '';\n                nameCell.style.opacity = '';\n            } else {\n                nameCell.style.textDecoration = 'line-through';\n                nameCell.style.opacity = '0.6';\n            }\n        }\n\n        // Re-render to apply ordering so checked items move to the end\n        if (this.currentTab === 'shopping') {\n            this.renderShoppingList();\n        }\n    }\n\n    removeItem(itemId) {\n        this.groceryItems = this.groceryItems.filter(item => String(item.id) !== String(itemId));\n        // Also remove from shopping list if present\n        if (this.shoppingSet.delete(itemId)) {\n            this.shoppingStore.set([...this.shoppingSet]).catch(err => console.error('Failed to persist shopping list:', err));\n        }\n        // Remove strike status tracking if present\n        if (this.uncheckedSet.delete(itemId)) {\n            this.shoppingStatusStore.set([...this.uncheckedSet]).catch(err => console.error('Failed to persist shopping status:', err));\n        }\n        this.applyCurrentFilter();\n        this.renderCurrentTab();\n        // Persist items\n        this.itemsStore.set(this.groceryItems).catch(err => console.error('Failed to persist items:', err));\n        Toast.show({type: 'success', message: 'Item removed successfully!'});\n    }\n\n    clearSelected() {\n        this.selectedItems.clear();\n        this.renderShoppingList();\n        // Persist selection\n        this.selectedStore.set([]).catch(err => console.error('Failed to persist selection:', err));\n        Toast.show({type: 'info', message: 'Selection cleared!'});\n    }\n\n    updateSelectedCount() {\n        // With the new UI, we display a static label for the clear shopping button\n        const clearBtn = document.getElementById('clear-shopping');\n        if (clearBtn) {\n            clearBtn.textContent = 'Clear Shopping List';\n        }\n    }\n\n    hideLoading() {\n        const loading = document.getElementById('loading');\n        if (loading && loading.style) {\n            loading.style.display = 'none';\n        }\n    }\n\n    showError(message) {\n        this.hideLoading();\n        const tbody = document.getElementById('shopping-tbody');\n        if (tbody) {\n            tbody.innerHTML = `\n                <tr>\n                    <td colspan=\"4\" style=\"text-align:center; color: var(--pico-del-color);\">Error: ${this.escapeHtml(message)}</td>\n                </tr>\n            `;\n        }\n    }\n\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    // Modal methods\n    openCreateModal() {\n        const modal = document.getElementById('item-modal');\n        const modalTitle = document.getElementById('modal-title');\n        const createForm = document.getElementById('add-item-form');\n        const editForm = document.getElementById('edit-item-form');\n        const submitBtn = document.getElementById('submit-modal');\n\n        // Reset editing state\n        this.editingItem = null;\n\n        // Configure modal for adding\n        modalTitle.textContent = 'Create Item';\n        createForm.style.display = 'block';\n        editForm.style.display = 'none';\n        submitBtn.textContent = '💾 Add Item';\n\n        // Reset add form\n        createForm.reset();\n\n        // Open modal\n        modal.showModal();\n    }\n\n    openEditModal() {\n        const modal = document.getElementById('item-modal');\n        const modalTitle = document.getElementById('modal-title');\n        const createForm = document.getElementById('add-item-form');\n        const editForm = document.getElementById('edit-item-form');\n        const submitBtn = document.getElementById('submit-modal');\n\n        // Configure modal for editing\n        modalTitle.textContent = 'Edit Item';\n        createForm.style.display = 'none';\n        editForm.style.display = 'block';\n        submitBtn.textContent = '💾 Update Item';\n\n        // Open modal\n        modal.showModal();\n    }\n\n    closeModal() {\n        const modal = document.getElementById('item-modal');\n        const createForm = document.getElementById('add-item-form');\n        const editForm = document.getElementById('edit-item-form');\n\n        // Reset forms\n        createForm.reset();\n        editForm.reset();\n\n        // Reset editing state\n        this.editingItem = null;\n\n        // Close modal\n        modal.close();\n    }\n\n    handleModalSubmit() {\n        if (this.editingItem) {\n            // Submit edit form\n            const editForm = document.getElementById('edit-item-form');\n            const event = new Event('submit', { bubbles: true, cancelable: true });\n            editForm.dispatchEvent(event);\n        } else {\n            // Submit add form\n            const createForm = document.getElementById('add-item-form');\n            const event = new Event('submit', { bubbles: true, cancelable: true });\n            createForm.dispatchEvent(event);\n        }\n    }\n\n    clearShoppingList() {\n        // Empty the shopping list and associated unchecked statuses\n        if (this.shoppingSet.size === 0) {\n            Toast.show({type: 'danger', message: 'Shopping list is already empty'});\n            return;\n        }\n        this.shoppingSet.clear();\n        this.uncheckedSet.clear();\n        // Persist\n        this.shoppingStore.set([]).catch(err => console.error('Failed to persist shopping list:', err));\n        this.shoppingStatusStore.set([]).catch(err => console.error('Failed to persist shopping status:', err));\n        // Re-render\n        if (this.currentTab === 'shopping') {\n            this.renderShoppingList();\n        }\n        Toast.show({type: 'success', message: 'Shopping list cleared'});\n    }\n\n    exportItems() {\n        try {\n            // Ensure we export the complete, current item list\n            const data = this.groceryItems.map(({ id, store, item, price }) => ({ id, store, item, price }));\n            const json = JSON.stringify(data, null, 2);\n\n            const blob = new Blob([json], { type: 'application/json' });\n            const url = URL.createObjectURL(blob);\n\n            const now = new Date();\n            const pad = (n) => String(n).padStart(2, '0');\n            const fileName = `groceries-items-${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;\n\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = fileName;\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n            URL.revokeObjectURL(url);\n\n            Toast.show({type: 'success', message: 'Item list exported'});\n        } catch (err) {\n            console.error('Failed to export items:', err);\n            Toast.error('Failed to export items');\n        }\n    }\n\n    async handleImportFile(file) {\n        try {\n            if (!(file instanceof File)) {\n                Toast.error('No file selected');\n                return;\n            }\n            const text = await new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(String(reader.result || ''));\n                reader.onerror = () => reject(reader.error || new Error('Failed to read file'));\n                reader.readAsText(file);\n            });\n\n            let data;\n            try {\n                data = JSON.parse(text);\n            } catch (parseErr) {\n                console.error('Invalid JSON file:', parseErr);\n                Toast.error('Invalid JSON file');\n                return;\n            }\n\n            if (!Array.isArray(data)) {\n                Toast.error('JSON must be an array of items');\n                return;\n            }\n\n            // Build indexes for fast checks\n            const existingIdSet = new Set(this.groceryItems.map(it => String(it.id)));\n            const existingKeySet = new Set(\n                this.groceryItems.map(it => `${String(it.store).trim().toLowerCase()}|${String(it.item).trim().toLowerCase()}`)\n            );\n\n            const toAdd = [];\n            let skippedInvalid = 0;\n            let skippedDuplicates = 0;\n            let counter = 0;\n\n            const makeUniqueId = () => {\n                let id;\n                do {\n                    id = `item-${Date.now()}-${counter++}`;\n                } while (existingIdSet.has(id));\n                existingIdSet.add(id);\n                return id;\n            };\n\n            for (const raw of data) {\n                // Basic shape check and normalization (accepts variations in key case/names)\n                const store = raw?.store ?? raw?.Store ?? raw?.STORE;\n                const name = raw?.item ?? raw?.name ?? raw?.Item ?? raw?.ITEM;\n                const priceRaw = raw?.price ?? raw?.Price ?? raw?.PRICE;\n\n                if (!store || !name) {\n                    skippedInvalid++;\n                    continue;\n                }\n\n                const item = String(name).trim();\n                const storeStr = String(store).trim();\n\n                // Parse price to number (default 0)\n                let price = Number(priceRaw);\n                if (!isFinite(price)) price = 0;\n\n                // Deduplicate by (store,item) pair\n                const key = `${storeStr.toLowerCase()}|${item.toLowerCase()}`;\n                if (existingKeySet.has(key)) {\n                    skippedDuplicates++;\n                    continue;\n                }\n                // Also prevent duplicates within the current batch\n                if (toAdd.some(x => `${x.store.toLowerCase()}|${x.item.toLowerCase()}` === key)) {\n                    skippedDuplicates++;\n                    continue;\n                }\n\n                // Ensure ID is present and unique\n                let id = raw?.id != null ? String(raw.id) : '';\n                if (!id || existingIdSet.has(id)) {\n                    id = makeUniqueId();\n                } else {\n                    existingIdSet.add(id);\n                }\n\n                toAdd.push({ id, store: storeStr, item, price });\n                existingKeySet.add(key);\n            }\n\n            if (toAdd.length === 0) {\n                if (skippedInvalid > 0) {\n                    Toast.show({type: 'warning', message: 'No items imported: invalid or duplicate entries'});\n                } else {\n                    Toast.show({type: 'info', message: 'No new items to import'});\n                }\n                return;\n            }\n\n            // Merge and persist\n            this.groceryItems.push(...toAdd);\n            await this.itemsStore.set(this.groceryItems);\n\n            // Reapply filter and re-render manage table\n            this.applyCurrentFilter();\n            this.renderCurrentTab();\n\n            const details = [];\n            if (skippedDuplicates) details.push(`${skippedDuplicates} duplicate(s) skipped`);\n            if (skippedInvalid) details.push(`${skippedInvalid} invalid item(s) skipped`);\n            const suffix = details.length ? ` (${details.join(', ')})` : '';\n            Toast.show({type: 'success', message: `Imported ${toAdd.length} item(s)${suffix}`});\n        } catch (err) {\n            console.error('Failed to import items:', err);\n            Toast.error('Failed to import items');\n        }\n    }\n}\n\n// Initialize the app when DOM is loaded\nwindow.groceryApp = null;\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.groceryApp = new GroceryApp();\n});\n","/**\n * Enhanced DataStore class for managing persistent data storage\n * Supports both Chrome extension storage API and browser localStorage fallback\n * @class DataStore\n */\nclass DataStore {\n    /**\n     * Create a DataStore instance\n     * @param {string} namespace - The storage namespace/key\n     * @param {string} [type='local'] - Storage type: 'local', 'sync', 'managed', 'session'\n     * @throws {Error} When namespace is invalid\n     */\n    constructor(namespace, type = 'local') {\n        this._validateNamespace(namespace);\n        this.namespace = namespace;\n        this.validTypes = ['local', 'sync', 'managed', 'session'];\n        this.type = this.validTypes.includes(type) ? type : 'local';\n        this._initializeStorage();\n        this._eventListeners = new Map();\n    }\n\n    /**\n     * Validate namespace parameter\n     * @private\n     * @param {*} namespace - The namespace to validate\n     * @throws {Error} When namespace is invalid\n     */\n    _validateNamespace(namespace) {\n        if (typeof namespace !== 'string') {\n            throw new TypeError('Namespace must be a string');\n        }\n        if (!namespace.trim()) {\n            throw new Error('Namespace cannot be empty');\n        }\n        if (namespace.length > 255) {\n            throw new Error('Namespace cannot exceed 255 characters');\n        }\n        if (!/^[a-zA-Z0-9._-]+$/.test(namespace)) {\n            throw new Error('Namespace contains invalid characters. Only alphanumeric, dots, underscores, and hyphens are allowed');\n        }\n    }\n\n    /**\n     * Initialize storage with Chrome extension API or localStorage fallback\n     * @private\n     */\n    _initializeStorage() {\n        try {\n            // Check if Chrome extension API is available\n            if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage[this.type]) {\n                this.storage = chrome.storage[this.type];\n                this.storageType = 'chrome';\n            } else {\n                // Fallback to localStorage/sessionStorage\n                this.storage = this.type === 'session' ? sessionStorage : localStorage;\n                this.storageType = 'web';\n            }\n        } catch (error) {\n            this.storage = localStorage;\n            this.storageType = 'web';\n            console.warn('DataStore: Falling back to localStorage due to:', error.message);\n        }\n    }\n\n    /**\n     * Get data from storage\n     * @param {*} [defaultValue=undefined] - Default value if key doesn't exist\n     * @returns {Promise<*>} The stored value or default value\n     */\n    async get(defaultValue = undefined) {\n        try {\n            if (this.storageType === 'chrome') {\n                return new Promise((resolve, reject) => {\n                    this.storage.get([this.namespace], (result) => {\n                        if (chrome.runtime.lastError) {\n                            reject(new Error(`Chrome storage error: ${chrome.runtime.lastError.message}`));\n                        } else {\n                            const value = result[this.namespace];\n                            resolve(value !== undefined ? value : defaultValue);\n                        }\n                    });\n                });\n            } else {\n                // Web storage fallback\n                const item = this.storage.getItem(this.namespace);\n                if (item === null) {\n                    return defaultValue;\n                }\n                try {\n                    return JSON.parse(item);\n                } catch (parseError) {\n                    console.warn(`DataStore: Failed to parse stored data for ${this.namespace}:`, parseError);\n                    return defaultValue;\n                }\n            }\n        } catch (error) {\n            console.error(`DataStore: Error getting data for ${this.namespace}:`, error);\n            throw new Error(`Failed to get data: ${error.message}`);\n        }\n    }\n\n    /**\n     * Set data in storage\n     * @param {*} value - The value to store\n     * @returns {Promise<void>}\n     * @throws {Error} When storage operation fails\n     */\n    async set(value) {\n        try {\n            this._validateValue(value);\n            if (this.storageType === 'chrome') {\n                return new Promise((resolve, reject) => {\n                    this.storage.set({ [this.namespace]: value }, () => {\n                        if (chrome.runtime.lastError) {\n                            reject(new Error(`Chrome storage error: ${chrome.runtime.lastError.message}`));\n                        } else {\n                            this._dispatchChangeEvent('set', value);\n                            resolve();\n                        }\n                    });\n                });\n            } else {\n                try {\n                    const serialized = JSON.stringify(value);\n                    this.storage.setItem(this.namespace, serialized);\n                    this._dispatchChangeEvent('set', value);\n                } catch (storageError) {\n                    if (storageError.name === 'QuotaExceededError') {\n                        throw new Error('Storage quota exceeded');\n                    }\n                    throw storageError;\n                }\n            }\n        } catch (error) {\n            console.error(`DataStore: Error setting data for ${this.namespace}:`, error);\n            throw new Error(`Failed to set data: ${error.message}`);\n        }\n    }\n\n    /**\n     * Validate that a value can be stored\n     * @private\n     * @param {*} value - The value to validate\n     * @throws {Error} When value cannot be stored\n     */\n    _validateValue(value) {\n        if (value === undefined) {\n            throw new Error('Cannot store undefined value');\n        }\n        try {\n            JSON.stringify(value);\n        } catch (error) {\n            if (error.message.includes('circular')) {\n                throw new Error('Cannot store value with circular references');\n            }\n            throw new Error(`Value is not serializable: ${error.message}`);\n        }\n    }\n\n    /**\n     * Add a value to an array stored in the namespace\n     * @param {*} value - The value to add\n     * @param {boolean} [allowDuplicates=true] - Whether to allow duplicate values\n     * @returns {Promise<number>} The new length of the array\n     * @throws {Error} When the stored data is not an array or value is invalid\n     */\n    async add(value, allowDuplicates = true) {\n        if (value === undefined || value === null) {\n            throw new Error(`Cannot add undefined or null value to \"${this.namespace}\"`);\n        }\n        try {\n            const data = await this.get([]);\n            if (!Array.isArray(data)) {\n                throw new Error(`\"${this.namespace}\" does not contain an array`);\n            }\n            if (!allowDuplicates && data.some(item => JSON.stringify(item) === JSON.stringify(value))) {\n                throw new Error('Duplicate value not allowed');\n            }\n            data.push(value);\n            await this.set(data);\n            return data.length;\n        } catch (error) {\n            console.error(`DataStore: Error adding value to ${this.namespace}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Clear all data in the entire namespace from storage\n     * @returns {Promise<void>}\n     * @throws {Error} When deletion fails\n     */\n    async clear() {\n        try {\n            if (this.storageType === 'chrome') {\n                return new Promise((resolve, reject) => {\n                    this.storage.remove([this.namespace], () => {\n                        if (chrome.runtime.lastError) {\n                            reject(new Error(`Chrome storage error: ${chrome.runtime.lastError.message}`));\n                        } else {\n                            this._dispatchChangeEvent('clear');\n                            resolve();\n                        }\n                    });\n                });\n            } else {\n                // Web storage fallback\n                this.storage.removeItem(this.namespace);\n                this._dispatchChangeEvent('clear');\n            }\n        } catch (error) {\n            console.error(`DataStore: Error deleting ${this.namespace}:`, error);\n            throw new Error(`Failed to delete data: ${error.message}`);\n        }\n    }\n\n    /**\n     * Append a value to an array at a specific path within the stored object\n     * @param {string} itemPath - Dot-notation path to the array (e.g., 'user.preferences.items')\n     * @param {*} value - The value to append\n     * @returns {Promise<number>} The new length of the array\n     * @throws {Error} When path is invalid, target is not an array, or value is invalid\n     */\n    async appendItem(itemPath, value) {\n        if (value === undefined || value === null) {\n            throw new Error(`Cannot add undefined or null value to \"${itemPath}\"`);\n        }\n        this._validatePath(itemPath);\n        try {\n            const data = await this.get();\n            if (!data) {\n                throw new Error(`No data found in namespace \"${this.namespace}\"`);\n            }\n            const { parent, key } = this._navigateToPath(data, itemPath);\n            if (!Array.isArray(parent[key])) {\n                throw new Error(`Path \"${itemPath}\" does not point to an array`);\n            }\n            parent[key].push(value);\n            await this.set(data);\n            return parent[key].length;\n        } catch (error) {\n            console.error(`DataStore: Error appending to ${itemPath}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Edit/update a value at a specific path within the stored object\n     * @param {string} itemPath - Dot-notation path to the value (e.g., 'user.name')\n     * @param {*} value - The new value\n     * @param {boolean} [createPath=false] - Whether to create the path if it doesn't exist\n     * @returns {Promise<void>}\n     * @throws {Error} When path is invalid or not found\n     */\n    async editItem(itemPath, value, createPath = false) {\n        this._validatePath(itemPath);\n        try {\n            let data = await this.get();\n            if (!data) {\n                if (createPath) {\n                    data = {};\n                } else {\n                    throw new Error(`No data found in namespace \"${this.namespace}\"`);\n                }\n            }\n            const { parent, key } = this._navigateToPath(data, itemPath, createPath);\n            if (!createPath && !(key in parent)) {\n                throw new Error(`Path \"${itemPath}\" not found`);\n            }\n            const oldValue = parent[key];\n            parent[key] = value;\n            await this.set(data);\n            this._dispatchChangeEvent('edit', { path: itemPath, oldValue, newValue: value });\n        } catch (error) {\n            console.error(`DataStore: Error editing ${itemPath}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Delete an item at a specific path within the stored object\n     * @param {string} itemPath - Dot-notation path to the value to delete\n     * @returns {Promise<boolean>} True if item was deleted, false if not found\n     * @throws {Error} When path is invalid\n     */\n    async deleteItem(itemPath) {\n        this._validatePath(itemPath);\n        try {\n            const data = await this.get();\n            if (!data) {\n                return false;\n            }\n            const { parent, key } = this._navigateToPath(data, itemPath);\n            if (!(key in parent)) {\n                return false;\n            }\n            const deletedValue = parent[key];\n            if (Array.isArray(parent)) {\n                const index = Number(key);\n                if (isNaN(index) || index < 0 || index >= parent.length) {\n                    throw new Error(`Invalid array index: ${key}`);\n                }\n                parent.splice(index, 1);\n            } else {\n                delete parent[key];\n            }\n            await this.set(data);\n            this._dispatchChangeEvent('deleteItem', { path: itemPath, deletedValue });\n            return true;\n        } catch (error) {\n            console.error(`DataStore: Error deleting ${itemPath}:`, error);\n            throw error;\n        }\n    }\n\n    // === UTILITY METHODS ===\n\n    /**\n     * Update data using a function\n     * @param {Function} updater - Function that receives current data and returns new data\n     * @param {*} [defaultValue] - Default value if no data exists\n     * @returns {Promise<*>} The updated data\n     */\n    async update(updater, defaultValue = undefined) {\n        if (typeof updater !== 'function') {\n            throw new TypeError('Updater must be a function');\n        }\n        try {\n            const currentData = await this.get(defaultValue);\n            const newData = updater(currentData);\n            await this.set(newData);\n            return newData;\n        } catch (error) {\n            console.error(`DataStore: Error updating ${this.namespace}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Merge an object with existing data\n     * @param {Object} newData - Object to merge\n     * @param {boolean} [deep=false] - Whether to perform deep merge\n     * @returns {Promise<Object>} The merged data\n     */\n    async merge(newData, deep = false) {\n        if (typeof newData !== 'object' || newData === null || Array.isArray(newData)) {\n            throw new TypeError('Data to merge must be a plain object');\n        }\n        try {\n            const currentData = await this.get({});\n            if (typeof currentData !== 'object' || Array.isArray(currentData)) {\n                throw new Error('Cannot merge with non-object data');\n            }\n\n            const merged = deep ? this._deepMerge(currentData, newData) : { ...currentData, ...newData };\n            await this.set(merged);\n            return merged;\n        } catch (error) {\n            console.error(`DataStore: Error merging data in ${this.namespace}:`, error);\n            throw error;\n        }\n    }\n\n    /**\n     * Validate a dot-notation path\n     * @private\n     * @param {string} path - The path to validate\n     */\n    _validatePath(path) {\n        if (typeof path !== 'string' || !path.trim()) {\n            throw new Error('Path must be a non-empty string');\n        }\n    }\n\n    /**\n     * Navigate to a path within an object, optionally creating missing parts\n     * @private\n     * @param {Object} data - The data object to navigate\n     * @param {string} path - Dot-notation path\n     * @param {boolean} [create=false] - Whether to create missing path parts\n     * @returns {Object} Object with parent and key properties\n     */\n    _navigateToPath(data, path, create = false) {\n        const pathParts = path.split('.');\n        const key = pathParts.pop();\n        let parent = data;\n        for (const part of pathParts) {\n            if (parent == null) {\n                throw new Error(`Cannot navigate through null/undefined at path \"${path}\"`);\n            }\n            if (!(part in parent)) {\n                if (create) {\n                    parent[part] = {};\n                } else {\n                    throw new Error(`Path \"${path}\" not found`);\n                }\n            }\n            parent = parent[part];\n        }\n        return { parent, key };\n    }\n\n    /**\n     * Deep merge two objects\n     * @private\n     * @param {Object} target - Target object\n     * @param {Object} source - Source object\n     * @returns {Object} Merged object\n     */\n    _deepMerge(target, source) {\n        const result = { ...target };\n        for (const key in source) {\n            if (source.hasOwnProperty(key)) {\n                if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key]) &&\n                    typeof result[key] === 'object' && result[key] !== null && !Array.isArray(result[key])) {\n                    result[key] = this._deepMerge(result[key], source[key]);\n                } else {\n                    result[key] = source[key];\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Dispatch change events\n     * @private\n     * @param {string} type - Event type\n     * @param {*} [data] - Event data\n     */\n    _dispatchChangeEvent(type, data = null) {\n        try {\n            if (typeof window !== 'undefined') {\n                window.dispatchEvent(new CustomEvent('datastore-changed', {\n                    detail: { \n                        namespace: this.namespace, \n                        type, \n                        data,\n                        timestamp: Date.now()\n                    }\n                }));\n            }\n            const listeners = this._eventListeners.get(type) || [];\n            listeners.forEach(callback => {\n                try {\n                    callback({ namespace: this.namespace, type, data });\n                } catch (error) {\n                    console.error('DataStore event listener error:', error);\n                }\n            });\n        } catch (error) {\n            console.warn('DataStore: Failed to dispatch change event:', error);\n        }\n    }\n\n    /**\n     * Add an event listener for DataStore changes\n     * @param {string} type - Event type ('set', 'clear', 'edit', 'deleteItem')\n     * @param {Function} callback - Callback function\n     */\n    addEventListener(type, callback) {\n        if (typeof callback !== 'function') {\n            throw new TypeError('Callback must be a function');\n        }\n        if (!this._eventListeners.has(type)) {\n            this._eventListeners.set(type, []);\n        }\n        this._eventListeners.get(type).push(callback);\n    }\n\n    /**\n     * Remove an event listener\n     * @param {string} type - Event type\n     * @param {Function} callback - Callback function to remove\n     */\n    removeEventListener(type, callback) {\n        const listeners = this._eventListeners.get(type);\n        if (listeners) {\n            const index = listeners.indexOf(callback);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n}\n\n// Export for module use\nexport { DataStore };\n\n// Make DataStore available globally\nif (typeof window !== 'undefined') {\n    window.DataStore = DataStore;\n}\n\n// Export default for easier importing\nexport default DataStore;"],"names":["$c369b942a8093473$export$47a0e4800a1fd7dc","namespace","type","_validateNamespace","validTypes","includes","_initializeStorage","_eventListeners","Map","TypeError","trim","Error","length","test","chrome","storage","storageType","sessionStorage","localStorage","error","console","warn","message","get","defaultValue","Promise","resolve","reject","result","runtime","lastError","value","undefined","item","getItem","JSON","parse","parseError","set","_validateValue","_dispatchChangeEvent","serialized","stringify","setItem","storageError","name","add","allowDuplicates","data","Array","isArray","some","push","clear","remove","removeItem","appendItem","itemPath","_validatePath","parent","key","_navigateToPath","editItem","createPath","oldValue","path","newValue","deleteItem","deletedValue","index","Number","isNaN","splice","update","updater","currentData","newData","merge","deep","merged","_deepMerge","create","pathParts","split","pop","part","target","source","hasOwnProperty","window","dispatchEvent","CustomEvent","detail","timestamp","Date","now","listeners","forEach","callback","addEventListener","has","removeEventListener","indexOf","DataStore","$54b47fc030b7b21e$var$GroceryApp","groceryItems","shoppingSet","Set","uncheckedSet","filteredItems","currentTab","editingItem","isLoading","itemsStore","shoppingStore","shoppingStatusStore","init","renderShoppingList","loadData","loadShopping","loadShoppingStatus","setupEventListeners","renderCurrentTab","hideLoading","stored","log","shopping","map","String","e","unchecked","document","getElementById","openCreateModal","closeModal","handleModalSubmit","createForm","handleCreateItem","editForm","handleEditItem","clearShoppingButton","clearShoppingList","filterByStoreManage","exportBtn","exportItems","importButton","importFileInput","userAgent","navigator","vendor","opera","isAndroid","isChrome","isAndroidChrome","tryFileSystemAccessPicker","event","preventDefault","handle","showOpenFilePicker","multiple","types","description","accept","file","getFile","handleImportFile","openInputPicker","showPicker","click","tagName","toLowerCase","getAttribute","ev","passive","setAttribute","files","setTimeout","renderManageTable","editBtn","closest","itemId","startEdit","removeBtn","itemCell","removeFromShopping","addToShopping","checkbox","toggleItem","formData","FormData","newItem","id","store","price","parseFloat","catch","err","applyCurrentFilter","reset","Toast","show","itemIndex","findIndex","find","openEditModal","cancelEdit","filterByStore","filter","currentFilter","filterSelect","tbody","toRender","innerHTML","isUnchecked","escapeHtml","toFixed","join","badge","inShopping","delete","row","querySelector","isChecked","checked","classList","nameCell","style","textDecoration","opacity","clearSelected","selectedItems","selectedStore","updateSelectedCount","clearBtn","textContent","loading","display","showError","text","div","createElement","modal","modalTitle","submitBtn","showModal","close","Event","bubbles","cancelable","size","json","blob","Blob","url","URL","createObjectURL","pad","n","padStart","fileName","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","a","href","download","body","appendChild","revokeObjectURL","File","reader","FileReader","onload","onerror","readAsText","parseErr","existingIdSet","it","existingKeySet","toAdd","skippedInvalid","skippedDuplicates","counter","makeUniqueId","raw","Store","STORE","Item","ITEM","priceRaw","Price","PRICE","storeStr","isFinite","x","details","suffix","groceryApp"],"version":3,"file":"groceries.50ac3565.js.map"}